# -*- coding: utf-8 -*-
"""Real.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZEbjsdsFqlqMgBPHUWHDjWsesGT93dST
"""

import os
import cv2
import numpy as np
import tensorflow as tf
import time  #  For measuring inference time

# ============ CONFIGURATION ============ #
os.environ['TF_CPP_MIN_LOG_LEVEL'] = '2'  # Suppress TensorFlow logs

MODEL_PATH = 'model/new_trained_ternaus_lat.keras'
VIDEO_PATH = 'realtime_videos/2.mp4'
SAVE_OUTPUT = True
OUTPUT_VIDEO_PATH = 'out/output_side_by_side_2.mp4'
THRESHOLD = 0.5
MODEL_INPUT_SIZE = (256, 256)
DISPLAY_WIDTH = 640
DISPLAY_HEIGHT = 360
# ======================================= #

# === Load Model === #
print(" Loading model...")
try:
    model = tf.keras.models.load_model(MODEL_PATH)
    print(" Model loaded successfully.")
except Exception as e:
    print(" Failed to load model:", str(e))
    exit()

# === Open Video === #
cap = cv2.VideoCapture(VIDEO_PATH)
if not cap.isOpened():
    print(" Error: Could not open video at", VIDEO_PATH)
    exit()

frame_width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
frame_height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
fps = int(cap.get(cv2.CAP_PROP_FPS))
print(f" Video loaded: {VIDEO_PATH} [{frame_width}x{frame_height} @ {fps}fps]")

# === Setup VideoWriter === #
if SAVE_OUTPUT:
    os.makedirs(os.path.dirname(OUTPUT_VIDEO_PATH), exist_ok=True)
    out = cv2.VideoWriter(
        OUTPUT_VIDEO_PATH,
        cv2.VideoWriter_fourcc(*'mp4v'),
        fps,
        (DISPLAY_WIDTH * 2, DISPLAY_HEIGHT)  # output side-by-side in smaller resolution
    )

print("ðŸš€ Starting real-time lane prediction... Press 'q' to quit.")

# === Frame-by-Frame Processing === #
frame_count = 0
while cap.isOpened():
    ret, frame = cap.read()
    if not ret:
        print(" Finished processing all frames.")
        break

    frame_count += 1

    # === Preprocessing === #
    resized = cv2.resize(frame, MODEL_INPUT_SIZE)
    normalized = resized / 255.0
    input_tensor = np.expand_dims(normalized, axis=0)

    # === Predict Lane Mask with Inference Timing === #
    start_time = time.time()
    prediction = model.predict(input_tensor, verbose=0)[0]
    inference_time_ms = (time.time() - start_time) * 1000  # in milliseconds

    binary_mask = (prediction > THRESHOLD).astype(np.uint8) * 255
    mask_resized = cv2.resize(binary_mask, (frame_width, frame_height))

    # === Create Overlay === #
    mask_bgr = cv2.cvtColor(mask_resized, cv2.COLOR_GRAY2BGR)
    overlay = cv2.addWeighted(frame, 0.8, mask_bgr, 0.2, 0)

    # === Resize frame and overlay for display === #
    frame_small = cv2.resize(frame, (DISPLAY_WIDTH, DISPLAY_HEIGHT))
    overlay_small = cv2.resize(overlay, (DISPLAY_WIDTH, DISPLAY_HEIGHT))

    # === Combine side-by-side === #
    combined = np.hstack((frame_small, overlay_small))

    # === Add inference time text === #
    cv2.putText(combined, f"Inference: {inference_time_ms:.2f} ms",
                (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 255, 255), 2)

    # === Display and optionally save === #
    cv2.imshow('Lane Detection | Left: Original | Right: Predicted', combined)
    if SAVE_OUTPUT:
        out.write(combined)

    # === Break on 'q' === #
    if cv2.waitKey(1) & 0xFF == ord('q'):
        print(" Interrupted by user.")
        break

# === Cleanup === #
cap.release()
if SAVE_OUTPUT:
    out.release()
cv2.destroyAllWindows()
print(f" Processed {frame_count} frames. All done.")